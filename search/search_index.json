{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Notes - React Query Udemy Course","text":"<ol> <li>Introduction to React Query</li> <li>Getting Started with React Query</li> <li>Handling Loading and Error states</li> <li>React Query DevTools</li> <li>Stale time vs Cache time 6.</li> </ol>"},{"location":"React%20Query/Udemy%20Course/Getting%20Started%20with%20React%20Query/","title":"Getting Started with React Query","text":"<p>The first project on the course is related to these subjects:</p> <ol> <li> <p>Data source: The project gets its data from <code>https://jsonplaceholder.typicode.com/</code> which provides a fake REST API for testing and prototyping.</p> </li> <li> <p>Simple and focused: The project is very simple and focuses on the core concepts of React Query. This makes it an excellent starting point for learning React Query.</p> </li> <li> <p>Fetching data: One of the main objectives of the project is to demonstrate how to fetch data using React Query. You will learn how to use the <code>useQuery</code> hook to query the server and access the results.</p> </li> <li> <p>Loading and error states: In addition to fetching data, you will also learn how to manage loading and error states. React Query provides a convenient way to manage these states and keep your components up-to-date.</p> </li> <li> <p>React Query dev tools: You will also learn how to use the React Query dev tools to inspect your queries, cache, and mutations. This is a valuable tool for debugging and optimizing your React Query application.</p> </li> <li> <p>Pagination: Pagination is a common feature in many applications, and React Query makes it easy to implement. In this project, you will learn how to use React Query to paginate your data.</p> </li> <li> <p>Prefetching: Prefetching is a performance optimization technique that can improve the loading time of your application. In this project, you will learn how to use React Query to prefetch your data.</p> </li> <li> <p>Mutations: Mutations are used to modify data on the server. In this project, you will learn how to use React Query to run mutations and update your cache.</p> </li> </ol>"},{"location":"React%20Query/Udemy%20Course/Getting%20Started%20with%20React%20Query/#getting-started-with-react-query","title":"Getting started with React Query","text":"<p>Getting started with React Query is easy, and you can begin by following these steps:</p> <ol> <li>Install the React Query library:</li> </ol> <pre><code>npm install @tanstack/react-query\n</code></pre> <ol> <li>Create a query client: The query client is responsible for managing all of your queries and cache. You can create a query client by using the <code>createQueryClient</code> function from the React Query library.</li> </ol> <pre><code>import { createQueryClient } from '@tanstack/react-query';\n\nconst queryClient = createQueryClient();\n</code></pre> <ol> <li>Apply the QueryProvider: The QueryProvider provides the query client and cache to all children components. You can wrap your root component in the QueryProvider and pass in the query client as the value.</li> </ol> <pre><code>import { QueryProvider } from '@tanstack/react-query';\n\nconst queryClient = createQueryClient();\n\nfunction App() {\n  return (\n    &lt;QueryProvider value={queryClient}&gt;\n      &lt;PostsList/&gt;\n    &lt;/QueryProvider&gt;\n  );\n}\n</code></pre> <ol> <li>Run the <code>useQuery</code> hook: The <code>useQuery</code> hook is the primary way to query the server in React Query. You can use the <code>useQuery</code> hook in your components to fetch data and access the results.</li> </ol> <pre><code>import { useQuery } from '@tanstack/react-query';\n\nconst fetchPosts = async () =&gt; {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts');\n  return response.json();\n};\n\nconst PostsList = () =&gt; {\n  const { data } = useQuery('posts', fetchPosts);\n\n  return (\n    &lt;ul&gt;\n      {data.map(post =&gt; (\n        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\n</code></pre> <p>In conclusion, these are the basic steps to get started with React Query. By following these steps, you will be able to quickly and easily query the server, manage your cache, and take advantage of the many other features of React Query.</p>"},{"location":"React%20Query/Udemy%20Course/Handling%20Loading%20and%20Error%20states/","title":"isFetching vs isLoading","text":"<p><code>isFetching</code> and <code>isLoading</code> are two important states provided by React Query to manage the status of a query or a mutation. Understanding the difference between these two states is crucial to effectively use React Query and provide a smooth user experience.</p> <p><code>isFetching</code> is a state that indicates whether a query is currently being executed. In other words, it means that the async function associated with the query has not yet resolved. This state is useful for indicating to the user that the application is currently fetching data from the server and that they need to wait for the response. When <code>isFetching</code> is <code>true</code>, the component using the query should display a loading indicator.</p> <p><code>isLoading</code> is a state that indicates whether a query is currently in a loading state. This state is more comprehensive than <code>isFetching</code> and takes into account two factors: (1) the absence of cached data and (2) the value of  <code>isFetching</code>. In other words, <code>isLoading</code> is <code>true</code> when there is no cached data and <code>isFetching</code> is <code>true</code>.</p> <p>When a query is <code>isLoading</code>, it means that the component using the query should display a loading indicator. This is because the query has either not started yet or it is currently being executed, and the application is waiting for a response from the server.</p> <p>In conclusion, <code>isFetching</code> and <code>isLoading</code> are two different states provided by React Query to manage the status of a query or a mutation. By using these states, you can effectively manage the loading state of an application and ensure that the user is informed about the status of the query. This helps provide a smooth and responsive user experience, even when the application is fetching data from the server.</p> <pre><code>import { useQuery } from '@tanstack/react-query';\n\nconst fetchPosts = async () =&gt; {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts');\n  return response.json();\n};\n\nconst PostsList = () =&gt; {\n  const { isLoading, isFetching, data, error } = useQuery(['posts'], fetchPosts);\n\n  if (error) {\n    return &lt;div&gt;An error has occurred: {error.message}&lt;/div&gt;;\n  }\n\n  if (isLoading) {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }\n\n  if (isFetching) {\n    return &lt;div&gt;Fetching new data...&lt;/div&gt;;\n  }\n\n  return (\n    &lt;ul&gt;\n      {data.map(post =&gt; (\n        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n</code></pre> <p>In this example, <code>isLoading</code> is <code>true</code> when there is no cached data and the fetching of data has not started yet. In this case, the component displays a \"Loading...\" message to inform the user that the application is waiting for data.</p> <p><code>isFetching</code> is <code>true</code> when the fetching of data has started, but the async function associated with the query has not yet resolved. In this case, the component displays a \"Fetching new data...\" message to inform the user that the application is currently fetching data from the server and that they need to wait for the response.</p> <p>In the case where an error has occurred, the component displays an error message to inform the user that something went wrong.</p>"},{"location":"React%20Query/Udemy%20Course/Handling%20Loading%20and%20Error%20states/#iserror","title":"isError","text":"<p>The <code>isError</code> state in React Query allows you to determine whether an error has occurred during the execution of a query or a mutation. This state is a boolean value that is set to <code>true</code> if there was an error, and <code>false</code> otherwise.</p> <p>The <code>error</code> object, on the other hand, contains information about the error that occurred. This object can be used to display more detailed error information to the user. For example, you could display the error message, status code, or other details associated with the error.</p> <p>Here is an example of how you can use the <code>isError</code> and <code>error</code> states in your React component:</p> <pre><code>import { useQuery } from '@tanstack/react-query';\n\nconst fetchPosts = async () =&gt; {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts');\n  return response.json();\n};\n\nconst PostsList = () =&gt; {\n  const { isLoading, isFetching, isError, error, data } = useQuery(['posts'], fetchPosts);\n\n  if (isError) {\n    return &lt;div&gt;An error has occurred: {error.message}&lt;/div&gt;;\n  }\n\n  if (isLoading) {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }\n\n  if (isFetching) {\n    return &lt;div&gt;Fetching new data...&lt;/div&gt;;\n  }\n\n  return (\n    &lt;ul&gt;\n      {data.map(post =&gt; (\n        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\n</code></pre>"},{"location":"React%20Query/Udemy%20Course/Handling%20Loading%20and%20Error%20states/#retries","title":"Retries","text":"<p>React Query will automatically retry a failed query or mutation up to three times by default. This is done to ensure that the request has a better chance of succeeding if it initially fails due to network issues or other temporary problems.</p> <p>However, you can modify this behavior by specifying the <code>retry</code> option when calling <code>useQuery</code>. For example, if you want to retry a query only once, you can set the <code>retry</code> option to <code>1</code>:</p> <pre><code>const { data, error } = useQuery(['posts'], fetchPosts, { retry: 1 });\n</code></pre> <p>In some cases, you may also want to specify a custom retry logic. You can do this by passing a function as the <code>retry</code> option. The function will receive the previous attempts as an argument, and it should return the number of remaining retries. For example, you can use a custom retry logic to only retry if the error code is specific:</p> <pre><code>const retry = (attempts) =&gt; {\n  if (attempts[attempts.length - 1].error.code === '429') {\n    return 1;\n  }\n\n  return 0;\n};\n\nconst { data, error } = useQuery(['posts'], fetchPosts, { retry: retry });\n</code></pre>"},{"location":"React%20Query/Udemy%20Course/Handling%20Loading%20and%20Error%20states/#onerror","title":"onError","text":"<p>React Query also provides a way to handle errors that occur during a query or mutation. You can use the <code>onError</code> option to specify a callback function that will be called when an error occurs. The function will receive the error as an argument.</p> <p>For example, you can use the <code>onError</code> option to display an error message to the user:</p> <pre><code>const onError = (error) =&gt; {\n  console.error(error);\n  alert('An error occurred while fetching the data. Please try again later.');\n};\n\nconst { data, error } = useQuery('posts', fetchPosts, { onError });\n</code></pre> <p>In this example, the <code>onError</code> callback function is called whenever an error occurs, and it logs the error to the console and displays an error message to the user using an <code>alert</code> function.</p> <p>Note that the <code>onError</code> option is only called if an error occurs, and it does not affect the retry behavior of React Query. If you want to modify the retry behavior, you can use the <code>retry</code> option as described in the previous paragraph.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/","title":"Client State vs Server State","text":"<p>Client state and server state are two different categories of data in a web application, with different properties and use cases. Understanding the difference between these two types of state is important for effectively managing data in a web application.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#client-state","title":"Client State","text":"<p>Client state refers to data that is relevant to a single browser session. It is stored in the client's browser and is accessible to the client-side code. This type of data is typically used to store information that is specific to the current user, such as their preferences or the state of the application.</p> <p>Examples of client state include:</p> <ul> <li>User's chosen language or theme</li> <li>Shopping cart items</li> <li>Current page or scroll position</li> <li>Form input values</li> </ul> <p>Client state is often stored in the browser's local storage, session storage, or in the React state. Because it is stored locally,  client state can be quickly accessed without having to make a round trip to the server. This can lead to a faster, more responsive user experience.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#server-state","title":"Server State","text":"<p>Server state, on the other hand, refers to data that is stored on the server and is accessible to both client-side and server-side code. This type of data is typically used to store information that needs to persist across multiple browser sessions, such as user account information or application data.</p> <p>Examples of server state include:</p> <ul> <li>User account information (e.g. username, email, password)</li> <li>Blog post data from the database</li> <li>Product information for an e-commerce website</li> <li>Analytics data</li> </ul> <p>Because server state is stored on the server, it is less prone to data loss or tampering than client state. However, accessing server state requires a round trip to the server, which can lead to slower performance and increased network overhead.</p> <p>In summary, both client state and server state have their own advantages and disadvantages, and understanding the differences between them is important for effectively managing data in a web application.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#what-problem-does-react-query-solve","title":"What problem does React Query solve?","text":"<p>React Query is a state management library that solves problems related to data fetching, caching, and updates in React applications. It provides a unified API for performing data operations and helps to manage the complexity of making asynchronous requests, handling errors, and updating the UI.</p> <p>React Query helps to simplify data management in React by:</p> <ol> <li>Automatically caching and deduplicating requests to reduce network overhead.</li> <li>Handling network errors and retries for you.</li> <li>Providing an API for manual cache updates and invalidations.</li> <li>Allowing for easy handling of optimistic updates and offline data changes.</li> </ol> <p>In summary, React Query helps to streamline and simplify the process of fetching and managing data in React, allowing you to focus on building great user experiences.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#react-query-manages-data","title":"React Query Manages Data","text":"<p>React Query is a state management library for React that makes it easier to manage data in your applications. One of the key features of React Query is its ability to cache data, which can improve the performance of your application by reducing the amount of network overhead.</p> <p>React Query provides two ways to manage data: imperatively and declaratively.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#imperative-cache-management","title":"Imperative Cache Management","text":"<p>With imperative cache management, you can manually control the cache by invalidating data as needed. This allows you to fine-tune the cache to meet your specific needs.</p> <p>For example, if you make a request for data from a server and the server returns an error, you can manually invalidate the cache to force a refetch of the data the next time it is requested. This can be useful for handling errors or for updating the cache with new data from the server.</p> <p>To invalidate the cache imperatively, you can use the <code>invalidate</code> method provided by React Query. For example:</p> <pre><code>const { data, error, isLoading } = useQuery(['posts', id], () =&gt; fetch(`/api/posts/${id}`));\n\nif (error) {\n  // Invalidate the cache if there was an error\n  data.invalidate();\n}\n</code></pre>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#declarative-cache-management","title":"Declarative Cache Management","text":"<p>With declarative cache management, you can configure when and how data is fetched and updated in the cache.</p> <p>For example, you can specify that data should only be refetched when the user has focus on the window, or when a specific interval has elapsed. This allows you to control the cache based on the user's experience and reduces the amount of unnecessary network overhead.</p> <p>To configure the cache declaratively, you can use the <code>config</code> option provided by React Query. For example:</p> <pre><code>const { data, error, isLoading } = useQuery(\n  ['posts', id],\n  () =&gt; fetch(`/api/posts/${id}`),\n  {\n    refetchOnWindowFocus: false,\n    refetchInterval: 60 * 60 * 1000, // 1 hour\n  }\n);\n</code></pre> <p>In this example, the data will only be refetched when the user focuses the window, or when an hour has passed, whichever comes first.</p> <p>By using both imperative and declarative cache management techniques, React Query provides you with the flexibility to manage your data in a way that works best for your application.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#other-features","title":"Other features","text":"<p>React Query offers several additional features that can help you manage data in your application more effectively.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#loading-and-error-states","title":"Loading and Error States","text":"<p>React Query provides loading and error states, which allow you to know when data is being fetched and when errors occur. This makes it easier to handle these situations in your application and provide a better user experience.</p> <p>For example, you can display a loading indicator while data is being fetched, or display an error message if there was an error fetching the data.</p> <pre><code>const { data, error, isLoading } = useQuery(['posts', id], () =&gt; fetch(`/api/posts/${id}`));\n\nif (isLoading) {\n  return &lt;p&gt;Loading...&lt;/p&gt;;\n}\n\nif (error) {\n  return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n}\n\nreturn &lt;div&gt;{data.title}&lt;/div&gt;;\n\n</code></pre>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#prefetching-data","title":"Prefetching Data","text":"<p>React Query provides a way to prefetch data, which allows you to load data in advance of when it is actually needed. This can help improve the performance of your application by reducing the amount of time it takes to load data when it is needed.</p> <p>For example, you can prefetch data when a user navigates to a new page in your application, which can reduce the amount of time it takes to load the data when the user actually needs it.</p> <pre><code>const prefetch = () =&gt; {\n  useQuery(['posts', id], () =&gt; fetch(`/api/posts/${id}`), { enabled: false });\n};\n\nfunction Home() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Home&lt;/h1&gt;\n      &lt;button onClick={prefetch}&gt;Prefetch&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#pagination-and-infinite-scroll","title":"Pagination and Infinite Scroll","text":"<p>React Query makes it easy to implement features such as pagination and infinite scroll, which can help you manage large amounts of data in your application.</p> <p>For example, you can use the <code>fetchMore</code> method provided by React Query to implement pagination, which allows you to load additional data as needed.</p> <pre><code>const { data, error, isLoading, fetchMore } = useQuery(\n  ['posts', page],\n  () =&gt; fetch(`/api/posts?page=${page}`)\n);\n\nreturn (\n  &lt;div&gt;\n    &lt;h1&gt;Posts&lt;/h1&gt;\n    {data.map(post =&gt; (\n      &lt;div key={post.id}&gt;{post.title}&lt;/div&gt;\n    ))}\n    &lt;button onClick={() =&gt; fetchMore({ page: page + 1 })}&gt;Load More&lt;/button&gt;\n  &lt;/div&gt;\n);\n</code></pre> <p>These are just a few examples of the ways that React Query can help you manage data in your application. With its flexible API and easy-to-use features, React Query provides a powerful tool for managing data in your React applications.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#de-duplication-of-requests-and-mutations","title":"De-duplication of Requests and Mutations","text":"<p>One of the key features of React Query is its ability to de-duplicate requests and mutations, which can help improve the performance of your application and reduce the amount of unnecessary network traffic.</p>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#de-duplication-of-requests","title":"De-duplication of Requests","text":"<p>React Query de-duplicates requests by caching the results of each request and reusing the cached data if the same request is made again. This can help improve the performance of your application by reducing the amount of network traffic and minimizing the amount of time spent waiting for data to be fetched.</p> <p>For example, if multiple components in your application need to fetch data for a user with the ID of <code>1</code>, React Query will only make a single request for that user's data and reuse the cached data for subsequent requests.</p> <pre><code>const { data } = useQuery(['user', 1], () =&gt; fetch(`/api/users/1`));\n</code></pre>"},{"location":"React%20Query/Udemy%20Course/Introduction%20to%20React%20Query/#de-duplication-of-mutations","title":"De-duplication of Mutations","text":"<p>React Query also de-duplicates mutations by ensuring that only one mutation is executed at a time for each unique set of variables. This can help improve the performance of your application by reducing the amount of network traffic and preventing race conditions.</p> <p>For example, if multiple components in your application need to update the same user's name, React Query will only execute a single mutation to update the user's name, even if multiple components trigger the mutation simultaneously.</p> <pre><code>const [updateUser, { isLoading }] = useMutation(variables =&gt;\n  fetch(`/api/users/${variables.id}`, {\n    method: 'PUT',\n    body: JSON.stringify(variables)\n  })\n);\n\nfunction UpdateUserForm() {\n  const [name, setName] = useState('');\n  const [id, setId] = useState('');\n\n  const handleSubmit = async e =&gt; {\n    e.preventDefault();\n    await updateUser({ id, name });\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input type=\"text\" value={id} onChange={e =&gt; setId(e.target.value)} /&gt;\n      &lt;input type=\"text\" value={name} onChange={e =&gt; setName(e.target.value)} /&gt;\n      &lt;button type=\"submit\" disabled={isLoading}&gt;\n        Update\n      &lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> <p>In conclusion, React Query's de-duplication of requests and mutations is a key feature that can help you improve the performance of your application and ensure that data is managed in a consistent and efficient manner.</p>"},{"location":"React%20Query/Udemy%20Course/React%20Query%20DevTools/","title":"React Query DevTools","text":"<p>React Query DevTools is a powerful tool that provides visibility into the state of your React Query cache. It helps you understand what queries are currently active, what their status is, when they were last updated, and what data they contain.</p> <p>The React Query DevTools show you a list of all the queries in your application, organized by query key. Each query is displayed with its status (e.g., \"loading\", \"error\", \"success\"), and its last updated timestamp. This gives you a clear understanding of which queries are currently running, which have completed successfully, and which have encountered an error.</p>"},{"location":"React%20Query/Udemy%20Course/React%20Query%20DevTools/#data-explorer","title":"Data Explorer","text":"<p>In addition to the query list, the React Query DevTools also include a data explorer. This allows you to explore the data in your React Query cache, see what data is stored for each query, and even modify the data if you need to. This is especially useful for debugging and testing purposes.</p>"},{"location":"React%20Query/Udemy%20Course/React%20Query%20DevTools/#query-explorer","title":"Query Explorer","text":"<p>The query explorer is another powerful feature of the React Query DevTools. It allows you to see the query configuration for each query, including its key, its endpoint, and any options or parameters that were passed to the <code>useQuery</code> hook. This can help you understand how your queries are configured, and what data they are retrieving from the server.</p> <p>In conclusion, the React Query DevTools are an essential tool for anyone working with React Query. They provide invaluable visibility into the state of your queries and cache, and help you understand how your application is managing its data. Whether you're developing a new application or troubleshooting an existing one, the React Query DevTools are an indispensable tool for building better, faster, and more reliable applications.</p>"},{"location":"React%20Query/Udemy%20Course/Stale%20time%20vs%20Cache%20time/","title":"Stale time vs Cache time","text":""},{"location":"React%20Query/Udemy%20Course/Stale%20time%20vs%20Cache%20time/#about-staletime","title":"About staleTime","text":"<p>React Query provides the option of setting a <code>staleTime</code> for your queries, which is the maximum amount of time that a query's data can be considered \"stale\" before it is automatically refetched. The concept of stale data is important because it allows us to ensure that the data displayed on the screen is always up to date, without having to constantly refetch it.</p> <p>The data refetch only triggers for stale data, such as when a component is remounted or the window refocuses. The <code>staleTime</code> value represents the \"max age\" of the data and is defined in milliseconds. The time you set for staleTime will depend on the nature of the data you are fetching - for example, you may want to tolerate data being potentially out of date for 10 seconds or 1 minute. When defining the <code>staleTime</code>, it is recommended to use the following syntax: <code>1000 * 60 * 10 // 10 minutes</code>.</p> <p>It's worth mentioning that the default <code>staleTime</code> is set to 0. The reasoning behind this is that it's a better question to ask \"How is the data on the screen always up to date?\" rather than \"Why is my data not updating?\".</p>"},{"location":"React%20Query/Udemy%20Course/Stale%20time%20vs%20Cache%20time/#staletime-vs-cachetime","title":"staleTime vs cacheTime","text":"<p>The <code>staleTime</code> and <code>cacheTime</code> are two different concepts in React Query. The <code>staleTime</code> is used for refetching data, while the <code>cacheTime</code> is used for data that may be reused later. If there is no active <code>useQuery</code> for a query, the query goes into \"cold storage\" and the cache data will expire after the <code>cacheTime</code> (which is set to five minutes by default). The cache time is based on how long it has been since the last active <code>useQuery</code>. Once the cache time has expired, the data is garbage collected.</p> <p>The <code>cache</code> serves as a backup data source to display while fetching. This allows for a smooth user experience even if there are slow or intermittent network issues. It is important to note that the <code>cacheTime</code> should be set based on how often the data is expected to change, as well as how important it is to display the most up-to-date information to the user.</p>"},{"location":"React%20Query/Udemy%20Course/Stale%20time%20vs%20Cache%20time/#notes-and-questions","title":"Notes and questions","text":"<ul> <li>Why does it matter if the data is stale?</li> <li>When a client retrieves data from a server, that data is only accurate at the time it was retrieved. Over time, the data can become stale and no longer reflect the current state of the system. In some cases, this might not matter, but in other cases, it can be crucial to have up-to-date data. For instance, when displaying stock prices or weather information, it's essential to have fresh data, and stale data might give the wrong information to the user.</li> <li>Data refetch only triggers for stale data</li> <li>React Query has a mechanism to manage stale data, and it only refetches data when it's stale. The staleTime parameter in React Query defines how long the data is considered stale and how long it should be displayed on the screen before refetching. For example, you can set the staleTime to 10 seconds, meaning that if the data was fetched more than 10 seconds ago, the data will be refetched.</li> <li>For example, component remount, window refocus</li> <li>React Query also has a mechanism to automatically refetch data when certain events occur, such as when a component is remounted or when the window regains focus. This way, the data displayed on the screen is always up-to-date.</li> <li>staleTime translates to \u201cmax age\u201d</li> <li>The staleTime parameter in React Query translates to the maximum age of the data that should be displayed on the screen. The staleTime is a way to manage the trade-off between the freshness of the data and the frequency of the requests. The staleTime should be set according to the nature of the data and the requirements of the application.</li> <li>How to tolerate data potentially being out of date? 10 seconds? 1 minute?</li> <li>This depends on the nature of the data The staleTime should be set according to the nature of the data and the requirements of the application. For instance, for stock prices or weather information, a staleTime of 10 seconds might be appropriate, whereas for blog posts or news articles, a staleTime of 1 minute might be more suitable.</li> <li>We always want to use the following syntax in the staleTime and cacheTime: 1000 _ 60 _ 10 // 10 minutes</li> <li>The staleTime and cacheTime are set in milliseconds, and the recommended syntax to use is to multiply the time in minutes by 60 and then by 1000. For example, if you want to set the staleTime to 10 minutes, you would use the following syntax: <code>1000 * 60 * 10 // 10 minutes</code>.</li> <li> <p>Why is default staleTime set to 0?</p> </li> <li> <p>The default staleTime is set to 0 because the React Query library is designed to always display up-to-date data. By setting the staleTime to 0, React Query will refetch data whenever it's needed, ensuring that the data displayed on the screen is always fresh.</p> </li> <li> <p>staleTime is for refetching</p> </li> <li>The staleTime parameter in React Query is used to determine when data should be refetched from the server. When the data is considered stale (as defined by the staleTime), React Query will automatically refetch the data.</li> <li>Cache is for data that might be re-used later</li> <li>The cacheTime parameter in React Query is used to manage the cache, which is used to store data that might be re-used later. The cacheTime defines how long the data will remain in the cache before it's considered stale and eligible for garbage collection.</li> </ul>"}]}